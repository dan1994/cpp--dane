# Huffman Coding Exercise Requirements

## Principle of Operation
- Create an executable that can:
	- Encode a textual file using either:
		- Canonical Huffman Coding
		- Huffman coding generated from the textual file
		- An arbitrary Huffman coding that was generated by this executable
	- Encoding may fail if the input file's alphabet is not contained in the requested coding scheme's alphabet.
	- Decode an encoded file generated by this executable
	- Generate a coding scheme from a textual file to be used later

## Output File Format
- Encoded files must be in one of two formats
	- A JSON file that follows the following structure:
		```json
		{
			"encoding": {
				"<encoded_char>": "<alphabet_char>",
				"<encoded_char>": "<alphabet_char>",
				...
				"<encoded_char>": "<alphabet_char>"
			},
			"encoded_text": "<encoded string>"
		}
		```
		- `alphabet_char` is a character from the original alphabet
		- `encoded_char` is an the encoded representation of a character from the alphabet
		- `encoded_string` is the representation of the input text file according to the given `encoding`
	- A binary format that follows the following structure:
		- TODO
- Generated Huffman coding files must be JSON files that follow the following structure:
	- ```json
		{
			"encoding": {
				"<encoded_char>": "<alphabet_char>",
				"<encoded_char>": "<alphabet_char>",
				...
				"<encoded_char>": "<alphabet_char>"
			}
		}
		```

## ABI
- `hed -h`
	- Print usage information
- `hed [-c | -i encoding_file] [-j] -e text_file output_file`
	- Encode `text_file` and save the result in `output_file`
		- If `-c` is given use canonical encoding
		- If `-i` is given import the encoding from `encoding_file`
		- Else generate the encoding
	- If `-j` is present, `output_file` should be in JSON format. Otherwise use the binary format
- `hed [-j] -d encoded_text_file output_file`
	- If `-j` is present, assume that `encoded_text_file` is in JSON format. Otherwise assume the binary format
- `hed -g text_file output_file`
